'.source.source.python': 
  'Read a mtz file into a miller array.':
    'prefix': 'millerMtzImports'
    'body': '''
      from iotbx.reflection_file_reader import any_reflection_file
      hkl_file = any_reflection_file("${1:3hz7.mtz}")
      miller_arrays = hkl_file.as_miller_arrays(merge_equivalents=False)
      $0
      
      ${0}
    '''
  'Print column labels in a Miller array.':
    'prefix': 'millerArrayLabels'
    'body': '''
      [print("Miller Array %s: %s" % (i, miller_array.info().labels)) for i, miller_array in list(enumerate(miller_arrays))[:2]]
      $0
      
      ${0}
    '''
  'Print wavelengths of each miller array.':
    'prefix': 'millerArrayWavelengths'
    'body': '''
      [print("Miller Array %s: %s" % (i, miller_array.info().wavelength)) for i, miller_array in list(enumerate(miller_arrays))]
      $0
      
      ${0}
    '''
  'Print the source of each miller array.':
    'prefix': 'millerArraySources'
    'body': '''
      print("Miller Array %s: %s" % (i, miller_array.info().source)) for i, miller_array in list(enumerate(miller_arrays))]
      $0
      
      ${0}
    '''
  'Print length of miller arrays (i.e., the number of datasets in a mtz file).':
    'prefix': 'millerArrayLengths'
    'body': '''
      len(miller_arrays)
      $0
      
      ${0}
    '''
  'Print the crystal symmetry of each miller array.':
    'prefix': 'millerArraySymmetry'
    'body': '''
      [print("Miller Array %s: %s" % (i, miller_array.info().crystal_symmetry_from_file)) for i, miller_array in list(enumerate(miller_arrays))]
      $0
      
      ${0}
    '''
  'Print all of the miller indices for a given Miller array.':
    'prefix': 'millerArrayHKLs'
    'body': '''
      [print(hkl) for hkl in miller_arrays[${1:0}].indices()]
      $0
      
      ${0}
    '''
  'Print the available methods for the Miller class.':
    'prefix': 'millerArrayMethods'
    'body': '''
      dir(miller_arrays[${1:0}])
      $0
      
      ${0}
    '''
  'Return the resolution range in d* in a specified Miller array.':
    'prefix': 'millerArraydstar'
    'body': '''
      miller_arrays[${1:0}].min_max_d_star_sq()
      $0
      
      ${0}
    '''
  'Return the resolution range in Angstroms for a Miller array.':
    'prefix': 'millerArrayDminDmax'
    'body': '''
      miller_arrays[${1:0}].d_max_min()
      $0
      
      ${0}
    '''
  'Return the I/sig overall for a given Miller array.':
    'prefix': 'millerArrayIsigma
'
    'body': '''
      miller_arrays[${1:0}].i_over_sig_i()
      $0
      
      ${0}
    '''
  'Return CC one-half sigma tau for a given Miller array.':
    'prefix': 'millerArrayCC'
    'body': '''
      miller_arrays[${1:0}].cc_one_half_sigma_tau()
      $0
      
      ${0}
    '''
  'Return CC one-half for a given Miller array. ':
    'prefix': 'millerArrayCConeHalf'
    'body': '''
      miller_arrays[${1:0}].cc_one_half()
      $0
      
      ${0}
    '''
  'Print the Bijvoet ratios in a specified Miller array.  May have to average by bin first.':
    'prefix': 'millerArrayBijvoetRatios'
    'body': '''
      [print(i) for i in miller_arrays[${1:0}].bijvoet_ratios()]
      $0
      
      ${0}
    '''
  'Return the `measurability` of the anomalous signal in a specified Miller array.':
    'prefix': 'millerArrayMeasurability'
    'body': '''
      miller_arrays[${1:0}].measurability()
      $0
      
      ${0}
    '''
  'Return the anomalous signal in a specified Miller array.':
    'prefix': 'millerArrayAnomalousSignal'
    'body': '''
      miller_arrays[${1:0}].anomalous_signal()
      $0
      
      ${0}
    '''
  'Show comprehensive summary for a specified Miller array. ':
    'prefix': 'millerArrayComprehensiveSummary'
    'body': '''
      miller_arrays[${1:0}].show_comprehensive_summary()
      $0
      
      ${0}
    '''
  'Show number of bijvoet pairs for a specified Miller array.':
    'prefix': 'millerArrayCountBijvoetPairs'
    'body': '''
      miller_arrays[${1:0}].n_bijvoet_pairs()
      $0
      
      ${0}
    '''
  'Show wilson ratio of miller array for a specified Miller array. ':
    'prefix': 'millerArrayWilsonRatio'
    'body': '''
      miller_arrays[${1:0}].wilson_ratio()
      $0
      
      ${0}
    '''
  'Unpack into I(+) and I(-) for a specified Miller array. ':
    'prefix': 'millerArrayUnpackIpIn'
    'body': '''
      Iobs = miller_arrays[${1:0}]
      i_plus, i_minus = Iobs.hemispheres_acentrics()
      ipd = i_plus.data()
      ip=list(ipd)
      imd = i_minus.data()
      im = list(imd)
      len(im)
      Iobs.show_summary()
      print(Iobs.info())
      print(Iobs.observation_type())
      $0
      
      ${0}
    '''
  'Print five rows of the Iobs for a specified Miller array. ':
    'prefix': 'millerArrayPrintSelectRows'
    'body': '''
      list(Iobs[${1:100:105}])
      $0
      
      ${0}
    '''
  'Extract just the intensities for a give Miller array and print ten rows of them.':
    'prefix': 'millerArrayExtractIntensities'
    'body': '''
      Iobs = miller_arrays[${1:0}]
      iobsdata = Iobs.data()
      list(iobsdata[${1:100:110}])
      $0
      
      ${0}
    '''
  'Print all of the intensities for a given Miller array.':
    'prefix': 'millerArrayPrintntensities'
    'body': '''
      [print(hkl) for hkl in miller_arrays[1].data()]
      $0
      
      ${0}
    '''
  'Convert the miller array into a mtz_dataset and write out as a mtz file.':
    'prefix': 'millerArrayconvert2mtz'
    'body': '''
      # Convert the miller array into a mtz_dataset and write out as a mtz file.
      mtz_dataset = Iobs.as_mtz_dataset(column_root_label="${1:I}")
      mtz_dataset.mtz_object().write("${2:3hz7intensities}.mtz")
      $0
      
      ${0}
    '''
  'Read in the mtz file and print its column labels as a sanity check.':
    'prefix': 'millerArrayReadMtz'
    'body': '''
      mtz_filename2 = "${1:3hz7intensities}.mtz"
      mtz_file2 = mtz.object(mtz_filename2)
      mtz_file2.column_labels()
      $0
      
      ${0}
    '''
  'Set up the arrays as dictionaries':
    'prefix': 'millerArray2Dictionary'
    'body': '''
      from iotbx import mtz
      mtz_obj = mtz.object(file_name="${1:3nd4}.mtz")
      # Only works with mtz.object. 
      # Does not work if mtz is read in with iotbx.file_reader.
      miller_arrays_dict = mtz_obj.as_miller_arrays_dict()
      $0
      
      ${0}
    '''
  'Print the miller keys() of a miller dictionary.':
    'prefix': 'millerArrayDictionaryKeys'
    'body': '''
      miller_arrays_dict.keys()
      $0
      
      ${0}
    '''
  'Print the column labels of Miller dictionary.':
    'prefix': 'millerArrayDictPrintColumns'
    'body': '''
      from iotbx import mtz
      mtz_obj = mtz.object(file_name="${1:/Users/blaine/3nd4.mtz}")
      # Only works with mtz.object. Does not work if mtz is read in with iotbx.file_reader.
      miller_arrays_dict = mtz_obj.as_miller_arrays_dict()
      [print(f"Column label: {key[2]}")  for key in miller_arrays_dict.keys()]
      $0
      
      ${0}
    '''
  'Peter Zwart's code for generating the indices for unit cell of given symmetry and dimensions. ':
    'prefix': 'millerArrayBuildFromUnitCell'
    'body': '''
      from cctbx import miller
      import cctbx
      from cctbx import crystal
      
      ms = miller.build_set(
          crystal_symmetry=crystal.symmetry(
              space_group_symbol="${1:Fd-3m}",
              unit_cell=(${2:5.4307,5.4307,5.4307,90.00,90.0,90.00})),
          anomalous_flag=${3:True},
          d_min=${4:0.4})
      
      [print(hkl) for hkl in ms.indices()]
      $0
      
      ${0}
    '''
  'Map generated reflections to the asu and print.':
    'prefix': 'millerArrayMapToASU'
    'body': '''
      from cctbx import miller
      import cctbx
      from cctbx import crystal
      
      ms = miller.build_set(
          crystal_symmetry=crystal.symmetry(
              space_group_symbol="${1:Fd-3m}",
              unit_cell=(${2:5.4307,5.4307,5.4307,90.00,90.0,90.00})),
          anomalous_flag=${3:True},
          d_min=${4:0.4})
      
      msu = ms.map_to_asu()
      [print(hkl2) for hkl2 in msu.indices()]
      $0
      
      ${0}
    '''
  'Read mtz file into a miller array and print summary.':
    'prefix': 'millerArrayPrintSummary'
    'body': '''
      from iotbx.reflection_file_reader import any_reflection_file
      hkl_in = any_reflection_file(file_name="${1:3nd4}.mtz")
      miller_arrays = hkl_in.as_miller_arrays()
      f_obs = miller_arrays[0]
      f_obs.show_summary()
      $0
      
      ${0}
    '''
  'Read mtz file into a mtz object and print summary.':
    'prefix': 'mtzObjectSummary'
    'body': '''
      from iotbx import mtz
      mtz_obj = mtz.object(file_name="/Users/blaine/${1:3nd4}.mtz")
      mtz_obj.show_summary()
      $0
      
      ${0}
    '''
  'Read mtz file into a Miller array.':
    'prefix': 'millerArrayFromMtz'
    'body': '''
      from iotbx import mtz
      mtz_obj = mtz.object(file_name="${1:3nd4}.mtz")
      miller_arrays = mtz_obj.as_miller_arrays()
      $0
      
      ${0}
    '''
  'Read mtz file into a Miller array, truncate, and print summary.':
    'prefix': 'millerArrayTruncate'
    'body': '''
      from iotbx import mtz
      mtz_obj = mtz.object(file_name="${1:3nd4}.mtz")
      miller_arrays = mtz_obj.as_miller_arrays()
      miller_array_truncated = miller_arrays[0].resolution_filter(d_min=${2:2}, d_max=${3:5})
      print(miller_array_truncated)
      miller_array_truncated.show_summary()
      $0
      
      ${0}
    '''
  'Print column labels of a Miller array dictionary.':
    'prefix': 'millerArrayDictColumnLabels'
    'body': '''
      [print(f"Column label: {key[2]}")  for key in miller_arrays_dict.keys()]
      $0
      
      ${0}
    '''
  'The conda commands to install cctbx with the jupyter notebook, pandas, and xarray.':
    'prefix': 'condaInstall'
    'body': '''
      conda create --name ${1:cctbx37} python=${2:3.7}
      conda activate ${1:cctbx37}
      conda install -c conda-forge cctbx-base jupyter pandas xarray
      $0
      
      ${0}
    '''
  'The conda commands to remove cctbx37 env.':
    'prefix': 'condaRemove'
    'body': '''
      conda remove --name ${1:cctbx37}
      
      ${0}
    '''
  'Fetch pdb file from RCSB in PDB format.':
    'prefix': 'fetchPDB'
    'body': '''
      from iotbx.pdb.fetch import get_pdb
      import sys
      get_pdb(id="${1:3nd4}",data_type="pdb", mirror="rcsb", format="pdb", log=sys.stdout)
      $0
      
      ${0}
    '''
  'Update the command line tools for Xcode on Mac OS X. ':
    'prefix': 'updateCLT'
    'body': '''
      sudo touch /tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress
      softwareupdate -l
      # Update command line tools via software update.
      sudo rm /tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress
      
      ${0}
    '''
  'Extract crystal symmetry from mtz file.':
    'prefix': 'extractCrystalSymmetry'
    'body': '''
      from __future__ import absolute_import, division, print_function
      from iotbx import mtz
      from cctbx import crystal
      
      def extract_from(file_name):
        mtz_object = mtz.object(file_name=file_name)
        assert mtz_object.n_symmetry_matrices() > 0
        return mtz_object.crystals()[0].crystal_symmetry()
        
       extract_from(file_name="${1:3nd4}.mtz")
       $0
      
      ${0}
    '''
  'Generate the list of dstars and logMeans as lists for plotting by matplotlib.':
    'prefix': 'plotDstarsLogMeans'
    'body': '''
      '''Generate the list of dstars and logMeans as lists
      for plotting by matplotlib.'''
      
      used = list(binner.range_used())
      selections = [binner.selection(i) for i in used]
      
      # make means of the intensities by bin
      means = [Iobs.select(sel).mean() for sel in selections]
      from math import log
      lnmeans = [log(y) for y in means]
      
      # meansBR = [Iobs.bijvoet_ratios().select(sel).mean() for sel in selections]
      
      # make d_centers
      d_star_power = 1.618034
      centers = binner.bin_centers(d_star_power)
      d_centers = list(centers**(-1 / d_star_power))
      
      %matplotlib inline
      import matplotlib.pyplot as plt
      import matplotlib as mpl
      mpl.rcParams["savefig.dpi"] = 600
      mpl.rcParams["figure.dpi"] = 600
      
      fig, ax = plt.subplots(figsize=[3.25, 2.])
      ax.scatter(d_centers,lnmeans,c="k",alpha=0.3,s=5.5)
      
      ax.set_xlim(${1:8, 1.5}) # decreasing time
      ax.set_xlabel(r"$d^*$ in $\AA$",fontsize=12)
      ax.set_ylabel("ln(I)",fontsize=12)
      plt.xticks(fontsize=12)
      plt.yticks(fontsize=12)
      ax.grid(False)
      plt.savefig("${2:3hz7}iobsvsdstar.pdf",bbox_inches="tight")
      plt.show()
      $0
      
      ${0}
    '''
  'Generate the list of dstars and measurability as lists for plotting by matplotlib.':
    'prefix': 'plotDstarsMeasurability'
    'body': '''
      from iotbx.reflection_file_reader import any_reflection_file
      hkl_file = any_reflection_file("${1:3hz7}.mtz")
      miller_arrays = hkl_file.as_miller_arrays(merge_equivalents=False)
      
      Iobs = miller_arrays[1]
      # Set up the bins
      n_bins = 50
      binner = Iobs.setup_binner(n_bins=n_bins)
      # binner.show_summary()
      used = list(binner.range_used())
      selections = [binner.selection(i) for i in used]
      
      # make d_centers for the x-axis
      d_star_power = 1.618034
      centers = binner.bin_centers(d_star_power)
      d_centers = list(centers**(-1 / d_star_power))
      
      # make list of the measurabilities by resolution bin
      meas = [Iobs.select(sel).measurability() for sel in selections]
      
      %matplotlib inline
      import matplotlib.pyplot as plt
      import matplotlib as mpl
      mpl.rcParams["savefig.dpi"] = 600
      mpl.rcParams["figure.dpi"] = 600
      
      fig, ax = plt.subplots(figsize=[3.25, 2.])
      ax.scatter(d_centers,lnmeans,c="k",alpha=0.3,s=5.5)
      
      ax.set_xlim(8, 1.5) # decreasing time
      ax.set_xlabel(r"$d^*$ in $\AA$",fontsize=12)
      ax.set_ylabel("ln(I)",fontsize=12)
      plt.xticks(fontsize=12)
      plt.yticks(fontsize=12)
      ax.grid(False)
      plt.savefig("${1:3hz7}measureability.pdf",bbox_inches="tight")
      plt.show()
      $0
      
      ${0}
    '''
  'Compute all possible Miller indices.':
    'prefix': 'computeAllMillerIndices'
    'body': '''
      from cctbx import miller
      
      def generate_reflection_indices(uc, dmin):
          maxh, maxk, maxl = uc.max_miller_indices(dmin)
      
          indices = []
      
          for h in range(-maxh, maxh + 1):
              for k in range(-maxk, maxk + 1):
                  for l in range(-maxl, maxl + 1):
                      if h == 0 and k == 0 and l == 0:
                          continue
                      if uc.d((h, k, l)) < dmin:
                          continue
              indices.append((h, k, l))
          return indices
          
      uc=(${1:5.4307,5.4307,5.4307,90.00,90.0,90.00})
      dmin=${2:1.0}
      $0
      
      ${0}
    '''
  'Compute all possible Miller indices in the ASU.':
    'prefix': 'computeAllMillerIndicesASU'
    'body': '''
      from cctbx import miller
      import cctbx
      from cctbx import crystal
      
      ms = miller.build_set(
          crystal_symmetry=crystal.symmetry(
              space_group_symbol="${1:Fd-3m}",
              unit_cell=("${2:5.4307,5.4307,5.4307,90.00,90.0,90.00}") ),
          anomalous_flag=${3:False},
          d_min=${4:0.4})
      
      for hkl in ms.indices():
          print(hkl)
      
      # map the reflections to the asu and print
        
      msu = ms.map_to_asu()
      [print(hkl2) for hkl2 in msu.indices()]
      $0
      
      ${0}
    '''
  'Build miller indices given unit cell and resolution limit.':
    'prefix': 'computeAllMillerIndicesUnitCell'
    'body': '''
      from cctbx import crystal
      from cctbx import miller
      
      ms = miller.build_set(
          crystal_symmetry=crystal.symmetry(
              space_group_symbol="${1:P4}",
              unit_cell=(${2:150.8,150.8,250.4,90.0,90.0,90.0})),
          anomalous_flag=${3:False},
          d_min=${4:1.4})
      msu = ms.map_to_asu()
      [print(hkl) for hkl in msu.indices()]
      print(msu.show_comprehensive_summary())
      $0
      
      ${0}
    '''
  'Extract the reflections from a mtz file.':
    'prefix': 'extractReflectionMtzFile'
    'body': '''
      from iotbx import mtz
      mtz_obj = mtz.object(file_name="${1:Users/blaine/manuscripts/RETkinaseLoxo/ret_blu.mtz}")
      mtz_obj.show_summary()
      $0
      
      ${0}
    '''
  'Extract the reflections in a shell.':
    'prefix': 'extractReflectionInShell'
    'body': '''
      from iotbx import mtz
      mtz_obj = mtz.object(file_name="${1:2V89}.mtz")
      miller_arrays = mtz_obj.as_miller_arrays()
      for miller_array in miller_arrays:
          miller_array_truncated = miller_array.resolution_filter(d_min=${2:2}, d_max=${3:5})
      print(miller_array_truncated)
      $0
      
      ${0}
    '''
  'Read in a phenix.refine mtz file. It plots the work and free R-factors by resolution bin.':
    'prefix': 'plotRfactorResolutionBin'
    'body': '''
      #!/usr/bin/env python
      # coding: utf-8
      ''' 
      This script reads in a phenix.refine mtz file.
      It plots the R-factor by resolution bin.
      The plots are made with matplotlib using miller arrays.
      It also plots the correlation coefficients.
      The plots were made with matplotlib.
      
      This script was adapted from an example script in iotbx:  
      
      Source:  https://github.com/cctbx/cctbx_project/blob/master/
      iotbx/examples/recalculate_phenix_refine_r_factors.py
      '''
      
      
      # get_ipython().run_line_magic("matplotlib", "inline")
      
      from __future__ import absolute_import, division, print_function
      from iotbx.reflection_file_utils import get_r_free_flags_scores
      from iotbx.file_reader import any_file
      import matplotlib
      import matplotlib.pyplot as plt
      
      
      
      def compute_r_factors(fobs, fmodel, flags):
        fmodel, fobs = fmodel.common_sets(other=fobs)
        fmodel, flags = fmodel.common_sets(other=flags)
        fc_work = fmodel.select(~(flags.data()))
        fo_work = fobs.select(~(flags.data()))
        fc_test = fmodel.select(flags.data())
        fo_test = fobs.select(flags.data())
        r_work = fo_work.r1_factor(fc_work)
        r_free = fo_test.r1_factor(fc_test)
        
        print("r_work = %.4f" % r_work)
        print("r_free = %.4f" % r_free)
        print("")
      
        binner = flags.setup_binner(n_bins=20)
        d_star_power = 1.618034
        centers = binner.bin_centers(d_star_power)
        d_centers = list(centers**(-1 / d_star_power))
      #   for i in d_centers:
      #     print(i)
          
        fo_work.use_binning_of(flags)
        fc_work.use_binner_of(fo_work)
        fo_test.use_binning_of(fo_work)
        fc_test.use_binning_of(fo_work)
      
        r_work_list = []
        r_free_list = []
        cc_work_list = []
        cc_free_list = []
        for i_bin in fo_work.binner().range_all():
          sel_work = fo_work.binner().selection(i_bin)
          sel_test = fo_test.binner().selection(i_bin)
          fo_work_bin = fo_work.select(sel_work)
          fc_work_bin = fc_work.select(sel_work)
          fo_test_bin = fo_test.select(sel_test)
          fc_test_bin = fc_test.select(sel_test)
          if fc_test_bin.size() == 0 : continue
              
          r_work_bin = fo_work_bin.r1_factor(other=fc_work_bin,
            assume_index_matching=True)
          r_work_list.append(r_work_bin)
          
          r_free_bin = fo_test_bin.r1_factor(other=fc_test_bin,
            assume_index_matching=True)
          r_free_list.append(r_free_bin)
          
          cc_work_bin = fo_work_bin.correlation(fc_work_bin).coefficient()
          cc_work_list.append(cc_work_bin)
          
          cc_free_bin = fo_test_bin.correlation(fc_test_bin).coefficient()
          cc_free_list.append(cc_free_bin)
          
          legend = flags.binner().bin_legend(i_bin, show_counts=False)
          print("%s  %8d %8d  %.4f %.4f  %.3f %.3f" % (legend, fo_work_bin.size(),
            fo_test_bin.size(), r_work_bin, r_free_bin, cc_work_bin, cc_free_bin))
          
        return d_centers, r_work_list, r_free_list, cc_work_list, cc_free_list
      
      
      def plot_r_factors(d_centers, r_work_list, r_free_list):
        plt.scatter(d_centers, r_work_list, label=r"$\mathit{R_{work}}$")
        plt.scatter(d_centers, r_free_list, label=r"$\mathit{R_{free}}$")
        plt.xlabel(r"Resolution ($\mathrm{\AA}$)")
        plt.ylabel(r"R-factor (%)")
        plt.legend(loc="upper right")
        plt.savefig("Rs.pdf")
        plt.close()
      
      
      def plot_cc(d_centers, cc_work_list, cc_free_list):
        plt.scatter(d_centers, cc_work_list, label=r"$\mathit{CC_{work}}$")
        plt.scatter(d_centers, cc_free_list, label=r"$\mathit{CC_{free}}$")
        plt.xlabel(r"Resolution ($\mathrm{\AA}$)")
        plt.ylabel(r"Correlation Coefficeint Fo vs Fc (%)")
        plt.legend(loc="lower right")
        plt.savefig("CCs.pdf")
      
      
      def run(input_mtz):
        mtz_in = any_file(input_mtz)
        ma = mtz_in.file_server.miller_arrays
        flags = fmodel = fobs = None
        # select the output arrays from phenix.refine.  This could easily be modified
        # to handle MTZ files from other programs.
        for array in ma :
          labels = array.info().label_string()
          if labels.startswith("R-free-flags"):
            flags = array
          elif labels.startswith("F-model"):
            fmodel = abs(array)
          elif labels.startswith("F-obs-filtered"):
            fobs = array
        if (None in [flags, fobs, fmodel]):
          raise RuntimeError("Not a valid phenix.refine output file")
        scores = get_r_free_flags_scores([flags], None)
        test_flag_value = scores.test_flag_values[0]
        flags = flags.customized_copy(data=flags.data()==test_flag_value)
      
        (d_centers, 
         r_work_list, 
         r_free_list, 
         cc_work_list, 
         cc_free_list) = compute_r_factors(fobs, fmodel, flags)
        plot_r_factors(d_centers, r_work_list, r_free_list)
        plot_cc(d_centers, cc_work_list, cc_free_list)
      
      
      if (__name__ == "__main__"):
        run(input_mtz="${1:28molrepEdited_5_refine_001}.mtz")
      $0
      
      ${0}
    '''
  'Example of computing Fcalcs and then plotting them by resolution bin. This script uses miller arrays and binner.':
    'prefix': 'plotFcalcsrResolutionBin'
    'body': '''
      '''
      This script reads in a phenix.refine mtz file.
      It plots the R-factor by resolution bin.
      The plots are made with matplotlib using miller arrays.
      It also plots the correlation coefficients.
      The plots were made with matplotlib.
      
      This script was adapted from an example script in iotbx:  
      
      Source:  https://github.com/cctbx/cctbx_project/blob/master/
      iotbx/examples/recalculate_phenix_refine_r_factors.py
      '''
      
      
      # get_ipython().run_line_magic("matplotlib", "inline")
      
      from __future__ import absolute_import, division, print_function
      from iotbx.reflection_file_utils import get_r_free_flags_scores
      from iotbx.file_reader import any_file
      import matplotlib
      import matplotlib.pyplot as plt
      
      
      
      def compute_r_factors(fobs, fmodel, flags):
        fmodel, fobs = fmodel.common_sets(other=fobs)
        fmodel, flags = fmodel.common_sets(other=flags)
        fc_work = fmodel.select(~(flags.data()))
        fo_work = fobs.select(~(flags.data()))
        fc_test = fmodel.select(flags.data())
        fo_test = fobs.select(flags.data())
        r_work = fo_work.r1_factor(fc_work)
        r_free = fo_test.r1_factor(fc_test)
        
        print("r_work = %.4f" % r_work)
        print("r_free = %.4f" % r_free)
        print("")
      
        binner = flags.setup_binner(n_bins=20)
        d_star_power = 1.618034
        centers = binner.bin_centers(d_star_power)
        d_centers = list(centers**(-1 / d_star_power))
      #   for i in d_centers:
      #     print(i)
          
        fo_work.use_binning_of(flags)
        fc_work.use_binner_of(fo_work)
        fo_test.use_binning_of(fo_work)
        fc_test.use_binning_of(fo_work)
      
        r_work_list = []
        r_free_list = []
        cc_work_list = []
        cc_free_list = []
        for i_bin in fo_work.binner().range_all():
          sel_work = fo_work.binner().selection(i_bin)
          sel_test = fo_test.binner().selection(i_bin)
          fo_work_bin = fo_work.select(sel_work)
          fc_work_bin = fc_work.select(sel_work)
          fo_test_bin = fo_test.select(sel_test)
          fc_test_bin = fc_test.select(sel_test)
          if fc_test_bin.size() == 0 : continue
              
          r_work_bin = fo_work_bin.r1_factor(other=fc_work_bin,
            assume_index_matching=True)
          r_work_list.append(r_work_bin)
          
          r_free_bin = fo_test_bin.r1_factor(other=fc_test_bin,
            assume_index_matching=True)
          r_free_list.append(r_free_bin)
          
          cc_work_bin = fo_work_bin.correlation(fc_work_bin).coefficient()
          cc_work_list.append(cc_work_bin)
          
          cc_free_bin = fo_test_bin.correlation(fc_test_bin).coefficient()
          cc_free_list.append(cc_free_bin)
          
          legend = flags.binner().bin_legend(i_bin, show_counts=False)
          print("%s  %8d %8d  %.4f %.4f  %.3f %.3f" % (legend, fo_work_bin.size(),
            fo_test_bin.size(), r_work_bin, r_free_bin, cc_work_bin, cc_free_bin))
          
        return d_centers, r_work_list, r_free_list, cc_work_list, cc_free_list
      
      
      def plot_r_factors(d_centers, r_work_list, r_free_list):
        plt.scatter(d_centers, r_work_list, label=r"$\mathit{R_{work}}$")
        plt.scatter(d_centers, r_free_list, label=r"$\mathit{R_{free}}$")
        plt.xlabel(r"Resolution ($\mathrm{\AA}$)")
        plt.ylabel(r"R-factor (%)")
        plt.legend(loc="upper right")
        plt.savefig("Rs.pdf")
        plt.close()
      
      
      def plot_cc(d_centers, cc_work_list, cc_free_list):
        plt.scatter(d_centers, cc_work_list, label=r"$\mathit{CC_{work}}$")
        plt.scatter(d_centers, cc_free_list, label=r"$\mathit{CC_{free}}$")
        plt.xlabel(r"Resolution ($\mathrm{\AA}$)")
        plt.ylabel(r"Correlation Coefficeint Fo vs Fc (%)")
        plt.legend(loc="lower right")
        plt.savefig("CCs.pdf")
      
      
      def run(input_mtz):
        mtz_in = any_file(input_mtz)
        ma = mtz_in.file_server.miller_arrays
        flags = fmodel = fobs = None
        # select the output arrays from phenix.refine.  This could easily be modified
        # to handle MTZ files from other programs.
        for array in ma :
          labels = array.info().label_string()
          if labels.startswith("R-free-flags"):
            flags = array
          elif labels.startswith("F-model"):
            fmodel = abs(array)
          elif labels.startswith("F-obs-filtered"):
            fobs = array
        if (None in [flags, fobs, fmodel]):
          raise RuntimeError("Not a valid phenix.refine output file")
        scores = get_r_free_flags_scores([flags], None)
        test_flag_value = scores.test_flag_values[0]
        flags = flags.customized_copy(data=flags.data()==test_flag_value)
      
        (d_centers, 
         r_work_list, 
         r_free_list, 
         cc_work_list, 
         cc_free_list) = compute_r_factors(fobs, fmodel, flags)
        plot_r_factors(d_centers, r_work_list, r_free_list)
        plot_cc(d_centers, cc_work_list, cc_free_list)
      
      
      if (__name__ == "__main__"):
        run(input_mtz="${1:28molrepEdited_5_refine_001}.mtz")
      
      ${0}
    '''
  'Miller arrays to plot of bin mean intensity over dstar':
    'prefix': 'plotIntensityResolutionBin'
    'body': '''
      from iotbx.file_reader import any_file
      import matplotlib.pyplot as plt
      
      f = any_file("${1:/Users/blaine/manuscripts/RETkinaseLoxo/ret_blu.mtz}")
      
      print(f.file_type)
      f.show_summary()
      miller_arrays = f.file_server.miller_arrays
      iobs =  miller_arrays[3]
      flags = miller_arrays[0]
      iobs, flags = iobs.common_sets(other=flags)
      iobsData = iobs.data()
      list(iobsData[100:110])
      iobs.show_comprehensive_summary()
      # iobs.binner()
      n_bins = ${2:20}
      binner = iobs.setup_binner(n_bins=n_bins)
      binner.show_summary()
      
      used = list(binner.range_used())
      selections = [binner.selection(i) for i in used]
      means = [iobs.select(sel).mean() for sel in selections]
      
      from math import log
      lnmeans = [log(y) for y in means]
      
      d_star_power = 1.618034
      centers = binner.bin_centers(d_star_power)
      d_centers = list(centers**(-1 / d_star_power))
      d_centers
      
      # plt.ylabel("Natural log of the amplitudes squared")
      # plt.xlabel(r"$\textrm{d^*}$ in $\textrm{\AA}$")
      # ax.set_xlim(35, 1.5)
      # plt.scatter(d_centers,lnmeanss)
      
      fig, ax = plt.subplots()
      ax.scatter(d_centers,lnmeans)
      ax.set_xlim(${3:8}, ${4:1.5})  # decreasing
      ax.set_xlabel(r"$d^*$ in $\AA$")
      ax.set_ylabel("Natural log of the intensities")
      ax.grid(False)
      plt.savefig("${5:iobsvsdstar}.pdf")
      $0
      
      ${0}
    '''
  'Miller arrays to convert CNS reflection file into an mtz file':
    'prefix': 'cns2mtz'
    'body': '''
      from iotbx import reflection_file_reader
      import os
      reflection_file = reflection_file_reader.any_reflection_file(file_name=os.path.expandvars("${1:\$CNS_SOLVE/doc/html/tutorial/data/pen/scale.hkl}"))
      from cctbx import crystal
      crystal_symmetry = crystal.symmetry( unit_cell=(${2:97.37, 46.64, 65.47, 90, 115.4, 90}), space_group_symbol="${3:C2}")
      miller_arrays = reflection_file.as_miller_arrays( crystal_symmetry=crystal_symmetry)
      mtz_dataset = None
      for miller_array in miller_arrays:
          if (mtz_dataset is None):
              mtz_dataset = miller_array.as_mtz_dataset(
                  column_root_label=miller_array.info().labels[0]) 
          else:
              mtz_dataset.add_miller_array(
                  miller_array=miller_array, 
                  column_root_label=miller_array.info().labels[0])
      mtz_object = mtz_dataset.mtz_object() 
      mtz_object.show_summary()
      $0
      
      ${0}
    '''
  'L-plot':
    'prefix': 'FsigmaFbyabsLindex'
    'body': '''
      import pandas as pd
      '''
      Use pandas to read in a hkl file with whitespace separators into a dataframe.
      Append to the dataframe a column with F/sigmaF values.
      Append to the dataframe a column with the absolute value of the L indices.
      Average F/sigmaF by absL index.
      Write to absL and F/sigmaF to csv file.
      '''
      mtzdata = pd.read_csv("${1:1524start}.hkl", names=["H","K","L",${2:"F","SIGF"}], sep="\s+")
      mtzdata["FovSigF"] = mtzdata.apply(lambda row: row["F"] / row["SIGF"], axis=1)
      mtzdata["absL"] = mtzdata.apply(lambda row: abs(row["L"]), axis=1)
      FovSigFabsL = mtzdata.groupby([mtzdata.absL]).FovSigF.mean()
      FovSigFabsL.to_csv("${3:test2}.csv")
      $0
      
      ${0}
    '''
  'Read in mtz file and write out with fewer columns.':
    'prefix': 'changeMtzColumns'
    'body': '''
      from iotbx.reflection_file_reader import any_reflection_file
      hkl_in = any_reflection_file("${1:/Users/blaine/manuscripts/RETkinaseLoxo/ret_blu.mtz}")
      
      miller_arrays = hkl_in.as_miller_arrays()
      
      i_obs =  miller_arrays[3]
      r_free_flags = miller_arrays[0]
      f_obs = i_obs.f_sq_as_f()
      
      mtz_dataset = i_obs.as_mtz_dataset(column_root_label="I")
      mtz_dataset.add_miller_array(f_obs, column_root_label="F")
      mtz_dataset.add_miller_array(r_free_flags,column_root_label="${2:FreeR_flag}")
      mtz_dataset.mtz_object().write("${3:loxodata.mtz}")
      $0
      
      ${0}
    '''
  'Calculate quasi-normalized structure factor.':
    'prefix': 'normalizedStructureFactors'
    'body': '''
      all_e_values = miller_array.quasi_normalize_structure_factors().sort(by_value="data")
      $0
      
      ${0}
    '''
  'Read in a mtz file into a Miller array with iotbx.file_reader.':
    'prefix': 'readMtzFile'
    'body': '''
      from iotbx.file_reader import any_file
      mtz_in = any_file("${1:data}.mtz", force_type="mtz")
      miller_arrays = mtz_in.file_server.miller_arrays
      $0
      
      ${0}
    '''
  'Read in a mtz file with iotbx.file_reader.':
    'prefix': 'pattersonContourMap'
    'body': '''
      import numpy
      from matplotlib import pyplot
      import gemmi
      # https://gemmi.readthedocs.io/en/latest/grid.html
      ccp4 = gemmi.read_ccp4_map("${1:/Users/blaine/4bqrPatterson.ccp4}")
      ccp4.setup()
      arr = numpy.array(ccp4.grid, copy=False)
      x = numpy.linspace(0, ccp4.grid.unit_cell.a, num=arr.shape[0], endpoint=False)
      y = numpy.linspace(0, ccp4.grid.unit_cell.b, num=arr.shape[1], endpoint=False)
      X, Y = numpy.meshgrid(x, y, indexing="ij")
      pyplot.rcParams["figure.figsize"] = (8.0, 8.0)
      pyplot.contour(X, Y, arr[:,:,0],500, zorder=1,linestyles="solid")
      pyplot.gca().set_aspect("equal", adjustable="box")
      pyplot.show()
      
      arr2 = numpy.array(ccp4.grid, copy=False)
      x = numpy.linspace(0, ccp4.grid.unit_cell.a, num=arr2.shape[0], endpoint=False)
      z = numpy.linspace(0, ccp4.grid.unit_cell.c, num=arr2.shape[1], endpoint=False)
      X, Z = numpy.meshgrid(x, z, indexing="ij")
      pyplot.rcParams["figure.figsize"] = (4.0, 20.5)
      pyplot.contour(X, Z, arr[:,:,0],500, zorder=1, linestyles="solid")
      pyplot.gca().set_aspect("equal", adjustable="box")
      pyplot.savefig("patterson.png", dpi=600)
      pyplot.show()
      $0
      
      ${0}
    '''
  'The conda commands to remove old env and create a new one for  cctbx. These commands need to be run on the command line.':
    'prefix': 'condaInstall2'
    'body': '''
      conda remove --name cctbx${1:37}
      conda create -n ${2:cctbx38} -c conda-forge cctbx-base python=${4:3.8}
      conda activate ${2:cctbx38}
      conda install -c conda-forge cctbx-base
      conda install -c anaconda ipykernel
      python -m ipykernel install --user --name ${2:cctbx38} --display-name "${2:cctbx38}"
      $0
      
      ${0}
    '''
  'The commands to find the eigenvalues and eigenvectors on a tensor. The code is from a post to cctbxbb on 10 December 2020 by Richard Gildea in a reply to Robert Oeffner about code in cctbx for finding eigenvalues and eigenvectors. Robert was requesting the analog in cctbx to scipy.linalg.eig.':
    'prefix': 'eigenvalues'
    'body': '''
      from scitbx.array_family import flex;
      from scitbx.linalg import eigensystem;
      m = flex.double(($1:-2, -4, 2, -2, 1, 2, 4, 2, 5}));
      m.reshape(flex.grid(3,3));
      es = eigensystem.real_symmetric(m);
      list(es.values());
      list(es.vectors());
      $0
      
      ${0}
    '''
  'Scatter plot of I(+) and (I(-). The presence of an anomalous signal is indicated by deviations from x=y.':
    'prefix': 'IpIm'
    'body': '''
      %matplotlib inline
      import matplotlib.pyplot as plt
      import matplotlib as mpl
      import matplotlib.ticker as ticker
      from matplotlib.ticker import MultipleLocator #, FormatStrFormatter
      from matplotlib.ticker import FuncFormatter
      from iotbx.reflection_file_reader import any_reflection_file
      
      # >>> change the mtz file name
      hkl_file = any_reflection_file("${1:3hz7}.mtz")
      miller_arrays = hkl_file.as_miller_arrays(merge_equivalents=False)
      Iobs = miller_arrays[1]
      i_plus, i_minus = Iobs.hemispheres_acentrics()
      ipd = i_plus.data()
      ip=list(ipd)
      imd = i_minus.data()
      im = list(imd)
      len(im)
      
      comma_fmt = FuncFormatter(lambda x, p: format(int(x), ","))
      
      mpl.rcParams["savefig.dpi"] = 600
      mpl.rcParams["figure.dpi"] = 600
      
      # Set to width of a one column on a two-column page.
      # May want to adjust settings for a slide.
      fig, ax = plt.subplots(figsize=[3.25, 3.25])
      ax.scatter(ip,im,c="k",alpha=0.3,s=5.5)
      ax.set_xlabel(r"I(+)",fontsize=12)
      ax.set_ylabel(r"I(-)",fontsize=12)
      ax.xaxis.set_major_locator(MultipleLocator(50000.))
      ax.yaxis.set_major_locator(MultipleLocator(50000.))
      ax.get_xaxis().set_major_formatter(comma_fmt)
      ax.get_yaxis().set_major_formatter(comma_fmt)
      
      plt.xticks(fontsize=12)
      plt.yticks(fontsize=12)
      ax.grid(False)
      
      # >>> change name of the figure file
      plt.savefig("${1:3hz7}IpIm.pdf",bbox_inches="tight")
      $0
      
      ${0}
    '''
  'Fetch fasta file from RCSB.':
    'prefix': 'fetchFASTA'
    'body': '''
      from iotbx.pdb.fetch import get_pdb
      import sys
      get_pdb(id="3nd4",data_type="pdb", mirror="rcsb", format="pdb", log=sys.stdout)
      $0
      
      ${0}
    '''
  'Fetch X-ray data from RCSB in mmCIF format.':
    'prefix': 'fetchXrayCif'
    'body': '''
      from iotbx.pdb.fetch import get_pdb
      import sys
      get_pdb(id="${1:3nd4}",data_type="xray", mirror="rcsb", format="cif", log=sys.stdout)
      $0
      
      ${0}
    '''
  'Fetch  atomic coordinates from RCSB in mmCIF format.':
    'prefix': 'fetchAtomicCif'
    'body': '''
      from iotbx.pdb.fetch import get_pdb
      import sys
      get_pdb(id="${1:3nd4}",data_type="xray", mirror="rcsb", format="cif", log=sys.stdout)
      $0
      
      ${0}
    '''
  'Print the symmetry from a PDB file.':
    'prefix': 'symmetryFromPDB'
    'body': '''
      import iotbx
      iotbx.pdb.crystal_symmetry_from_pdb.extract_from("${1:3nd4}.pdb")
      $0
      
      ${0}
    '''
  'Read in mtz and pdb file and write map coefficients to a separate mtz file.':
    'prefix': 'makeMaps'
    'body': '''
      from mmtbx.maps.utils import create_map_from_pdb_and_mtz
      '''The phenix.maps commandline tool is the recommended approach.'''
      id="${1:3nd4}"
      create_map_from_pdb_and_mtz(
                pdb_file="%s.pdb" % id,
                mtz_file="%s.mtz" % id,
                output_file="%s_maps.mtz" % id,
                fill=False,
                out=None,
                llg_map=False,
                remove_unknown_scatterering_type=True,
                assume_pdb_data=False)
      $0
      
      ${0}
    '''
  'Enter this snippet on the command line in an empty directory.':
    'prefix': 'testCCTBX'
    'body': '''
      libtbx.run_tests_parallel module=libtbx module=cctbx nproc=${1:6}
      $0
      
      ${0}
    '''
  'Enter this snippet on the command line in an empty directory.':
    'prefix': 'condaInstall4Ununtu'
    'body': '''
      apt install nodejs git
      wget https://repo.anaconda.com/archive/${1:Anaconda3-2020.02-Linux-x86_64.sh}
      bash ${1:Anaconda3-2020.02-Linux-x86_64.sh}
      conda create -n ${2:pc37} python=3.7 schrodinger::pymol-bundle=2.4.1 conda-forge::cctbx-base conda-forge::jupyter
      conda activate ${2:pc37}
      conda install conda-forge::jupyterlab=2.2.0
      # The following may be needed
      # jupyter serverextension enable --py jupyterlab --user 
      pip install jupyterlab-snippets-multimenus
      jupyter lab build
      # Might be needed
      # jupyter lab clean
      jupyter --path # select the top option under Data for storing the libraries
      cd ~/.local/share/jupyter # change as per output from prior line
      mkdir multimenus_snippets
      cd multimenus_snippets
      git clone https://github.com/MooersLab/juptyerlabpymolcctbx.git cctbx
      git clone https://github.com/MooersLab/juptyerlabpymolcctbxplus.git cctbx+
      git clone https://github.com/MooersLab/juptyerlabpymolpysnips.git pymol
      git clone https://github.com/MooersLab/juptyerlabpymolpysnipsplus.git pymol+
      jupyter lab # or libtbx.python -m jupyter-lab
      $0
      
      ${0}
    '''
  'List the currently available envs. The bang (!) enables running this command in a Juptyer Notebook. Delete the bang to run the command in the terminal.':
    'prefix': 'condaListEnvs'
    'body': '''
      !conda env list
      
      ${0}
    '''
  'Remove a specified env. The bang (!) enables running this command in a Juptyer Notebook. Delete the bang to run the command in the terminal.':
    'prefix': 'condaRemoveEnv'
    'body': '''
      !conda env remove --name cctbx37
      
      ${0}
    '''
  'Install cctbx inside PyMOL. This protocol worked on a Mac OS.':
    'prefix': 'condaInstallCCTBXInsidePyMOL'
    'body': '''
      # At the PyMOL prompt in the PyMOL GUI paste the following:
      conda install conda-forge::cctbx-base conda-forge::jupyter 
      conda install conda-forge::jupyterlab=2.2.0
      conda install conda-forge::cctbx-base
      # In a terminal
      /Applications/PyMOL.app/Contents/bin/jupyter serverextension enable --py jupyterlab --user
      /Applications/PyMOL.app/Contents/bin/ipython kernel install --name pymol --user
      /Applications/PyMOL.app/Contents/bin/pip install jupyterlab-snippets-multimenus
      /Applications/PyMOL.app/Contents/bin/jupyter lab build
      /Applications/PyMOL.app/Contents/bin/jupyter lab clean
      /Applications/PyMOL.app/Contents/bin/jupyter --path # select the top option under Data for storing the libraries
      cd ~.local/share/jupyter # change as per output from prior line
      mkdir multimenus_snippets
      cd multimenus_snippets
      git clone https://github.com/MooersLab/juptyerlabpymolcctbx.git cctbx
      git clone https://github.com/MooersLab/juptyerlabpymolcctbxplus.git cctbx+
      git clone https://github.com/MooersLab/juptyerlabpymolpysnips.git pymol
      git clone https://github.com/MooersLab/juptyerlabpymolpysnipsplus.git pymol+
      /Applications/PyMOL.app/Contents/bin/ipython kernel install --name pymol37 --user
      $0
      
      ${0}
    '''
  'Bash script to test new installation of cctbx with Python3.7 in a conda env.':
    'prefix': 'testCCTBXpython38'
    'body': '''
      #! /bin/sh
      set noglob
      set verbose
      libtbx.python $CONDA_PREFIX/lib/python3.8/site-packages/libtbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.8/site-packages/iotbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.8/site-packages/boost_adptbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.8/site-packages/fable/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.8/site-packages/scitbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.8/site-packages/cctbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.8/site-packages/cctbx/run_examples.py
      libtbx.python $CONDA_PREFIX/lib/python3.8/site-packages/smtbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.8/site-packages/cflib_adaptbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.8/site-packages/reduce/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.8/site-packages/mmtbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.8/site-packages/cctbx_website/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.8/site-packages/gltbx/run_tests.py
      
      ${0}
    '''
  'Bash script to test new installation of cctbx with Python3.8 in a conda env.':
    'prefix': 'testCCTBXpython37'
    'body': '''
      #! /bin/sh
      set noglob
      set verbose
      libtbx.python $CONDA_PREFIX/lib/python3.7/site-packages/libtbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.7/site-packages/iotbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.7/site-packages/boost_adptbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.7/site-packages/fable/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.7/site-packages/scitbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.7/site-packages/cctbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.7/site-packages/cctbx/run_examples.py
      libtbx.python $CONDA_PREFIX/lib/python3.7/site-packages/smtbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.7/site-packages/cflib_adaptbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.7/site-packages/reduce/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.7/site-packages/mmtbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.7/site-packages/cctbx_website/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.7/site-packages/gltbx/run_tests.py
      
      ${0}
    '''
  'Command to install gemmi (https://github.com/project-gemmi/gemmi). Documentation is located here (https://gemmi.readthedocs.io/en/latest/install.html).':
    'prefix': 'gemmiInstall'
    'body': '''
      # Install from PyPi
      pip install gemmi
      # OR install the latest version directly from github.
      pip install git+https://github.com/project-gemmi/gemmi.git
      
      ${0}
    '''
  'Fix permission on MacOS SDK. Adjust the version number of the sdk as needed.':
    'prefix': 'fixPermissionsOnMacSDK'
    'body': '''
      cd /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/
      sudo ln -s MacOSX.sdk MacOSX10.15.sdk
      
      ${0}
    '''
  'Print the average B factor for all atoms.':
    'prefix': 'averageB'
    'body': '''
      from iotbx import pdb
      pdb_name = '~/${1:Downloads/4RBQ}.pdb'
      pdb_inp = pdb.input(file_name=pdb_name)
      atoms = pdb_inp.atoms()
      bfactors = atoms.extract_b()
      bfactors.format_mean("%6.2f Ang.^2")
      $0
      
      ${0}
    '''
  'Bash script to test new installation of cctbx with Python3.9 in a conda env.':
    'prefix': 'testCCTBXpython39'
    'body': '''
      #! /bin/sh
      set noglob
      set verbose
      libtbx.python $CONDA_PREFIX/lib/python3.9/site-packages/libtbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.9/site-packages/iotbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.9/site-packages/boost_adptbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.9/site-packages/fable/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.9/site-packages/scitbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.9/site-packages/cctbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.9/site-packages/cctbx/run_examples.py
      libtbx.python $CONDA_PREFIX/lib/python3.9/site-packages/smtbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.9/site-packages/cflib_adaptbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.9/site-packages/reduce/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.9/site-packages/mmtbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.9/site-packages/cctbx_website/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.9/site-packages/gltbx/run_tests.py
      
      ${0}
    '''
  'Bash script to test new installation of cctbx with Python3.10 in a conda env.':
    'prefix': 'testCCTBXpython310'
    'body': '''
      #! /bin/sh
      set noglob
      set verbose
      libtbx.python $CONDA_PREFIX/lib/python3.10/site-packages/libtbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.10/site-packages/iotbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.10/site-packages/boost_adptbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.10/site-packages/fable/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.10/site-packages/scitbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.10/site-packages/cctbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.10/site-packages/cctbx/run_examples.py
      libtbx.python $CONDA_PREFIX/lib/python3.10/site-packages/smtbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.10/site-packages/cflib_adaptbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.10/site-packages/reduce/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.10/site-packages/mmtbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.10/site-packages/cctbx_website/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.10/site-packages/gltbx/run_tests.py
      
      ${0}
    '''
  'Bash script to test new installation of cctbx with Python3.11 in a conda env.':
    'prefix': 'testCCTBXpython311'
    'body': '''
      #! /bin/sh
      set noglob
      set verbose
      libtbx.python $CONDA_PREFIX/lib/python3.11/site-packages/libtbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.11/site-packages/iotbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.11/site-packages/boost_adptbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.11/site-packages/fable/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.11/site-packages/scitbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.11/site-packages/cctbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.11/site-packages/cctbx/run_examples.py
      libtbx.python $CONDA_PREFIX/lib/python3.11/site-packages/smtbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.11/site-packages/cflib_adaptbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.11/site-packages/reduce/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.11/site-packages/mmtbx/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.11/site-packages/cctbx_website/run_tests.py
      libtbx.python $CONDA_PREFIX/lib/python3.11/site-packages/gltbx/run_tests.py
      
      ${0}
    '''
